<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Scavenger: Matrix Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .hud-row {
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 5px #000;
        }
        .label { font-weight: bold; font-size: 20px; min-width: 100px; }
        .value { font-size: 20px; color: #fff; }

        /* Focus Bar */
        #focus-container {
            width: 200px;
            height: 10px;
            background: #333;
            border: 2px solid #555;
        }
        #focus-fill {
            width: 100%;
            height: 100%;
            background: #00ffaa;
            box-shadow: 0 0 10px #00ffaa;
            transition: width 0.1s linear;
        }

        #score-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            text-shadow: 0 0 20px #0f0;
            color: #0f0;
            display: none;
            text-align: center;
            font-weight: 900;
            z-index: 10;
        }
        
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 20;
        }
        h1 { margin: 0; font-size: 50px; color: #00FFFF; text-shadow: 0 0 15px #00FFFF; }
        p { font-size: 18px; color: #ccc; max-width: 600px; text-align: center; line-height: 1.5; }
        button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            background: #00AAFF;
            border: none;
            color: white;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 0 15px #00AAFF;
        }
        button:hover { background: #0088CC; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-row">
        <div class="label" style="color:#00FFFF">WEAPON:</div>
        <div class="value" id="weapon-display">DATA-BLADE</div>
    </div>
    <div class="hud-row">
        <div class="label" style="color:#FFFF00">AMMO:</div>
        <div class="value" id="ammo-display">∞</div>
    </div>
    <div class="hud-row">
        <div class="label" style="color:#00FF00">FOCUS:</div>
        <div id="focus-container"><div id="focus-fill"></div></div>
    </div>
    <div class="hud-row">
        <div class="label">LEVEL:</div>
        <div class="value" id="level-display">1</div>
    </div>
</div>

<div id="score-ui">
    <div class="value" id="score-display">SCORE: 0</div>
    <div class="value" id="combo-display" style="color: #ff0055; display: none; font-size:24px;">COMBO x2</div>
</div>

<div id="message">SYSTEM HACKED</div>

<div id="start-overlay">
    <h1>NEON SCAVENGER</h1>
    <p>WASD to Move | SPACE to Dash (Invincible) | SHIFT to Slow Time<br>
       L-CLICK to Shoot | R-CLICK to Throw Gun (Instakill)<br>
       Pickup weapons to stack ammo.</p>
    <button onclick="startGame()">INITIALIZE SYSTEM</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/** * AUDIO SYSTEM (Web Audio API) 
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.2) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    shoot: function(type) {
        if(type === 'Pistol') this.playTone(600, 'square', 0.1, 0.1);
        if(type === 'Shotgun') { this.playNoise(0.2, 0.3); this.playTone(150, 'sawtooth', 0.2, 0.2); }
        if(type === 'SMG') this.playTone(800, 'sawtooth', 0.05, 0.05);
        if(type === 'Grenade Launcher') this.playTone(200, 'triangle', 0.3, 0.2);
        if(type === 'Data-Blade') this.playNoise(0.1, 0.1); // Swish
    },
    explode: function() { this.playNoise(0.5, 0.4); },
    dash: function() { this.playTone(300, 'sine', 0.3, 0.1); },
    slowMo: function(start) { 
        if(start) this.playTone(100, 'sine', 0.5, 0.1); 
    }
};

/**
 * GAME SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// UI Elements
const uiWeapon = document.getElementById('weapon-display');
const uiAmmo = document.getElementById('ammo-display');
const uiLevel = document.getElementById('level-display');
const uiFocus = document.getElementById('focus-fill');
const uiScore = document.getElementById('score-display');
const uiCombo = document.getElementById('combo-display');
const msgEl = document.getElementById('message');

let width, height;
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input
const keys = {};
const mouse = { x: 0, y: 0 };

// State
let level = 1;
let score = 0;
let gameState = 'start'; 
let frameCount = 0;
let timeScale = 1.0; 
let baseTimeScale = 1.0; // Modified by slow-mo

// Combo
let comboCount = 0;
let comboTimer = 0;

// Entities
let player;
let enemies = [];
let bullets = [];
let particles = [];
let walls = [];
let pickups = [];
let floatingTexts = [];
let ghosts = []; // For dash trails
let explosions = [];

// Camera
let camShake = 0;

/** UTILS */
function rand(min, max) { return Math.random() * (max - min) + min; }
function getAngle(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1); }
function checkRectCollide(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}
// Line Intersection
function lineIntersectRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    const check = (x3,y3,x4,y4) => {
        const uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
        const uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
        return (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1);
    }
    return check(x1,y1,x2,y2, rx,ry,rx,ry+rh) || 
           check(x1,y1,x2,y2, rx+rw,ry,rx+rw,ry+rh) ||
           check(x1,y1,x2,y2, rx,ry,rx+rw,ry) ||
           check(x1,y1,x2,y2, rx,ry+rh,rx+rw,ry+rh);
}
function hasLineOfSight(ent1, ent2) {
    for (let w of walls) {
        if (lineIntersectRect(ent1.x, ent1.y, ent2.x, ent2.y, w.x, w.y, w.w, w.h)) return false;
    }
    return true;
}

/**
 * CLASSES
 */

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.life = 1.0;
    }
    update() { this.y -= 1 * timeScale; this.life -= 0.02 * timeScale; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = "bold 20px Courier New";
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

class Weapon {
    constructor(type) {
        this.type = type;
        this.cooldown = 0;
        this.maxCooldown = 0;
        this.ammo = 0;

        if (type === 'Pistol') {
            this.color = '#FFFF00'; this.ammo = 12; this.maxCooldown = 15;
        } else if (type === 'Shotgun') {
            this.color = '#00FFFF'; this.ammo = 6; this.maxCooldown = 45;
        } else if (type === 'SMG') {
            this.color = '#AA00FF'; this.ammo = 40; this.maxCooldown = 5;
        } else if (type === 'Grenade Launcher') {
            this.color = '#00FF00'; this.ammo = 5; this.maxCooldown = 60;
        } else {
            // Blade
            this.type = 'Data-Blade'; this.color = '#FFFFFF'; this.ammo = Infinity; this.maxCooldown = 25;
        }
    }
}

class Bullet {
    constructor(x, y, angle, speed, color, owner, type) {
        this.x = x; this.y = y; this.angle = angle;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        this.color = color; this.owner = owner; // 'player' or 'enemy'
        this.type = type; // 'normal', 'melee', 'thrown', 'grenade', 'rail'
        this.life = (type==='melee') ? 8 : (type==='grenade' ? 120 : 100);
        this.radius = (type==='melee') ? 80 : (type==='grenade' ? 6 : 3);
        this.dead = false;
    }
    update() {
        if (this.type !== 'melee') {
            this.x += this.vx * timeScale;
            this.y += this.vy * timeScale;
        }
        this.life -= 1 * timeScale;
        if (this.life <= 0) {
            this.dead = true;
            if(this.type === 'grenade') createExplosion(this.x, this.y);
        }

        // Wall Collision
        if (this.type !== 'rail' && this.type !== 'melee') {
            for (let w of walls) {
                if (this.x > w.x && this.x < w.x + w.w && this.y > w.y && this.y < w.y + w.h) {
                    this.dead = true;
                    if (this.type === 'grenade') createExplosion(this.x, this.y);
                    else spawnParticles(this.x, this.y, this.color, 2);
                    return;
                }
            }
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.type === 'melee') {
            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = '#FFF';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, this.angle - Math.PI/2, this.angle + Math.PI/2);
            ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fill();
        } else if (this.type === 'thrown') {
            ctx.rotate(frameCount*0.5); ctx.fillStyle = this.color; ctx.fillRect(-6,-6,12,12);
        } else if (this.type === 'grenade') {
            ctx.fillStyle = '#00FF00'; ctx.shadowBlur = 10; ctx.shadowColor='#00FF00';
            ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Explosion {
    constructor(x, y) {
        this.x = x; this.y = y; this.radius = 10; this.maxRadius = 80;
        this.life = 1.0;
    }
    update() {
        this.radius += 5 * timeScale;
        this.life -= 0.05 * timeScale;
    }
    draw() {
        if(this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = '#00FF00';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 20; this.h = 20;
        this.weapon = new Weapon('Data-Blade');
        this.angle = 0; this.dead = false;
        
        // Abilities
        this.focus = 100; this.maxFocus = 100;
        this.dashTimer = 0; this.dashCooldown = 0;
        this.isDashing = false;
    }

    update() {
        // Look at mouse
        this.angle = getAngle(this.x, this.y, mouse.x, mouse.y);

        // BULLET TIME
        let slowActive = false;
        if (keys['ShiftLeft'] && this.focus > 0) {
            baseTimeScale = 0.3;
            this.focus -= 0.5; // Drain
            slowActive = true;
            if(!AudioSys.slowPlaying) { AudioSys.slowMo(true); AudioSys.slowPlaying = true; }
        } else {
            baseTimeScale = 1.0;
            if (this.focus < this.maxFocus) this.focus += 0.2; // Recharge
            AudioSys.slowPlaying = false;
        }
        
        // DASH
        if (this.dashTimer > 0) this.dashTimer -= 1 * timeScale; // Duration
        else this.isDashing = false;
        
        if (this.dashCooldown > 0) this.dashCooldown -= 1 * timeScale;

        if (keys['Space'] && this.dashCooldown <= 0 && !this.isDashing) {
            this.isDashing = true;
            this.dashTimer = 10; // Frames
            this.dashCooldown = 60; // 1 sec
            AudioSys.dash();
            // Create ghost
            ghosts.push({x:this.x, y:this.y, angle:this.angle, life:0.5});
        }

        // Movement
        let dx = 0, dy = 0;
        if (keys['KeyW']) dy = -1;
        if (keys['KeyS']) dy = 1;
        if (keys['KeyA']) dx = -1;
        if (keys['KeyD']) dx = 1;

        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
            
            // Speed: Normal 4, Dash 12
            let speed = this.isDashing ? 15 : 4; 
            
            // PREDICTIVE WALL SLIDING (Axis Separation)
            let moveX = dx * speed * timeScale;
            let moveY = dy * speed * timeScale;

            // X check
            let testX = this.x + moveX;
            if (!this.checkWallCollision(testX, this.y)) {
                this.x = testX;
            }
            // Y check
            let testY = this.y + moveY;
            if (!this.checkWallCollision(this.x, testY)) {
                this.y = testY;
            }
        }
        
        if(this.isDashing && frameCount % 3 === 0) {
             ghosts.push({x:this.x, y:this.y, angle:this.angle, life:0.4});
        }

        // Weapon Cooldown
        if (this.weapon.cooldown > 0) this.weapon.cooldown -= 1 * timeScale;

        // Pickup collision
        for (let i = pickups.length - 1; i >= 0; i--) {
            let p = pickups[i];
            let dist = Math.hypot(this.x - p.x, this.y - p.y);
            if (dist < 20) {
                if (this.weapon.type === p.type && this.weapon.type !== 'Data-Blade') {
                    // AMMO STACK
                    this.weapon.ammo += p.ammo;
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "AMMO UP", "#FFF"));
                } else {
                    // SWAP
                    this.weapon = new Weapon(p.type);
                    this.weapon.ammo = p.ammo; // take drop ammo
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, p.type, p.color));
                }
                pickups.splice(i, 1);
                AudioSys.playTone(400, 'sine', 0.1);
            }
        }
        
        // Update UI Focus Bar
        uiFocus.style.width = (this.focus / this.maxFocus * 100) + "%";
    }

    checkWallCollision(x, y) {
        for(let w of walls) {
            if(checkRectCollide({x: x-10, y: y-10, w: 20, h: 20}, w)) return true;
        }
        return false;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Ghost effect handled in main draw loop
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.isDashing ? '#00FFFF' : '#FFFFFF';
        ctx.fillStyle = this.isDashing ? '#AAFFFF' : '#FFFFFF';
        ctx.fillRect(-10, -10, 20, 20);
        
        // Gun
        ctx.fillStyle = this.weapon.color;
        ctx.fillRect(5, -4, 12, 8);
        ctx.restore();
    }

    shoot() {
        if (this.weapon.cooldown > 0) return;

        let spread = 0;
        if (this.weapon.type === 'SMG') spread = 0.2;

        const fireBullet = (angleOffset, speed, typeOverride) => {
            let angle = this.angle + angleOffset + rand(-spread, spread);
            let bType = typeOverride || 'normal';
            if(this.weapon.type === 'Grenade Launcher') bType = 'grenade';
            
            bullets.push(new Bullet(this.x, this.y, angle, speed, this.weapon.color, 'player', bType));
        };

        if (this.weapon.type === 'Data-Blade') {
            bullets.push(new Bullet(this.x, this.y, this.angle, 0, '#FFF', 'player', 'melee'));
            this.weapon.cooldown = this.weapon.maxCooldown;
            camShake = 2;
            AudioSys.shoot('Data-Blade');
        } 
        else if (this.weapon.ammo > 0) {
            AudioSys.shoot(this.weapon.type);
            camShake = (this.weapon.type === 'Grenade Launcher') ? 8 : 4;
            
            if (this.weapon.type === 'Pistol') fireBullet(0, 12);
            else if (this.weapon.type === 'SMG') fireBullet(0, 14);
            else if (this.weapon.type === 'Grenade Launcher') fireBullet(0, 8);
            else if (this.weapon.type === 'Shotgun') {
                for(let i=-2; i<=2; i++) fireBullet(i*0.1, 12);
            }

            this.weapon.ammo--;
            this.weapon.cooldown = this.weapon.maxCooldown;
        }
    }

    throwWeapon() {
        if (this.weapon.type === 'Data-Blade') return;
        bullets.push(new Bullet(this.x, this.y, this.angle, 15, this.weapon.color, 'player', 'thrown'));
        this.weapon = new Weapon('Data-Blade');
        AudioSys.playTone(200, 'square', 0.1);
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.w = 20; this.h = 20;
        this.type = type; this.angle = 0; this.dead = false;
        this.color = '#F00';
        // Sniper/Shield State
        this.state = 0; this.timer = 0;
    }

    update() {
        if (this.dead) return;
        const dist = Math.hypot(player.x - this.x, player.y - this.y);
        const angleToPlayer = getAngle(this.x, this.y, player.x, player.y);
        const canSee = hasLineOfSight(this, player);

        // Physics
        const move = (spd) => {
            let nextX = this.x + Math.cos(this.angle) * spd * timeScale;
            let nextY = this.y + Math.sin(this.angle) * spd * timeScale;
            // Simple wall check
            let hit = false;
            for(let w of walls) if(checkRectCollide({x:nextX-10,y:nextY-10,w:20,h:20}, w)) hit = true;
            if(!hit) { this.x = nextX; this.y = nextY; }
        };

        if (this.type === 'Rusher') {
            this.angle = angleToPlayer;
            move(2.5);
            if (dist < 25) killPlayer();
        } 
        else if (this.type === 'Shield') {
            // Turn Slowly
            let diff = angleToPlayer - this.angle;
            while (diff < -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            this.angle += diff * 0.05 * timeScale;
            
            if (dist > 100) move(1.0);
            else if (this.timer-- <= 0 && canSee) {
                 // Shield occasionally shoots
                 bullets.push(new Bullet(this.x, this.y, this.angle, 8, '#F00', 'enemy', 'normal'));
                 this.timer = 120;
                 AudioSys.playTone(400, 'sawtooth', 0.1);
            }
        }
        else if (this.type === 'Sniper') {
            if (this.state === 0) { // Idle
                if(canSee) { this.state = 1; this.timer = 90; }
                else { this.angle += rand(-0.1, 0.1)*timeScale; move(0.5); }
            } else if (this.state === 1) { // Charge
                this.angle = angleToPlayer;
                this.timer -= 1 * timeScale;
                if(this.timer <= 0) {
                    bullets.push(new Bullet(this.x, this.y, this.angle, 30, '#F0F', 'enemy', 'rail'));
                    this.state = 2; this.timer = 120;
                    AudioSys.playTone(800, 'square', 0.3);
                    camShake = 5;
                }
            } else if (this.state === 2) { // Cooldown
                this.timer -= 1 * timeScale;
                if(this.timer <= 0) this.state = 0;
            }
        }
    }

    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        
        if(this.type === 'Rusher') {
            ctx.fillStyle = '#0F0'; ctx.shadowColor = '#0F0'; ctx.shadowBlur=10;
            ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.fill();
        } else if (this.type === 'Shield') {
            ctx.fillStyle = '#00F';
            ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.fill();
            ctx.strokeStyle = '#00AAFF'; ctx.lineWidth=4; ctx.beginPath();
            ctx.arc(0,0,22,-Math.PI/2, Math.PI/2); ctx.stroke();
        } else if (this.type === 'Sniper') {
            ctx.fillStyle = '#A0F'; ctx.shadowColor = '#A0F'; ctx.shadowBlur=10;
            ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-10,8); ctx.lineTo(-6,0); ctx.lineTo(-10,-8); ctx.fill();
            if(this.state === 1) {
                ctx.restore(); ctx.save();
                ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(player.x, player.y); ctx.stroke();
                ctx.restore(); return;
            }
        }
        ctx.restore();
    }
}

/**
 * GAME ENGINE
 */
function createExplosion(x, y) {
    explosions.push(new Explosion(x, y));
    camShake = 10;
    AudioSys.explode();
    
    // AOE Damage
    for(let i = enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        if (Math.hypot(e.x - x, e.y - y) < 80) killEnemy(i, e);
    }
}

function spawnParticles(x, y, color, speed) {
    for(let i=0; i<15; i++) {
        particles.push({
            x:x, y:y, color:color, size: rand(2,5),
            vx: Math.cos(rand(0,Math.PI*2))*rand(1,speed),
            vy: Math.sin(rand(0,Math.PI*2))*rand(1,speed),
            life: 1.0
        });
    }
}

function killEnemy(index, e) {
    spawnParticles(e.x, e.y, e.color, 4);
    AudioSys.playTone(100, 'sawtooth', 0.2); // Death sound
    
    // Scoring & Combo
    if(comboTimer > 0) comboCount++; else comboCount = 1;
    comboTimer = 90; // 1.5s
    let pts = 100 * comboCount;
    score += pts;
    floatingTexts.push(new FloatingText(e.x, e.y, `+${pts}`, comboCount > 1 ? '#FF0' : '#FFF'));

    // Drops (50%)
    if (Math.random() < 0.5) {
        let dropType = 'Pistol';
        let r = Math.random();
        if(e.type === 'Shield') dropType = 'Shotgun';
        else if(e.type === 'Sniper') dropType = 'SMG';
        else if(r > 0.8) dropType = 'Grenade Launcher';
        else if(r > 0.5) dropType = 'SMG';
        
        pickups.push({x: e.x, y: e.y, type: dropType, ammo: new Weapon(dropType).ammo, color: new Weapon(dropType).color});
    }

    enemies.splice(index, 1);
}

function killPlayer() {
    if(player.isDashing) return; // Invincible
    player.dead = true;
    spawnParticles(player.x, player.y, '#FFF', 6);
    camShake = 20;
    AudioSys.explode();
    setTimeout(() => {
        level = 1; score = 0;
        startGame();
    }, 2000);
}

function generateLevel() {
    walls = []; enemies = []; pickups = []; bullets = []; particles = []; explosions = []; ghosts = [];
    
    // Borders
    walls.push({x:0, y:0, w:width, h:20});
    walls.push({x:0, y:height-20, w:width, h:20});
    walls.push({x:0, y:0, w:20, h:height});
    walls.push({x:width-20, y:0, w:20, h:height});

    // Random Walls
    for(let i=0; i<10+level; i++) {
        walls.push({
            x: rand(50, width-200), y: rand(50, height-200),
            w: rand(50, 150), h: rand(50, 150)
        });
    }

    // Player
    player = new Player(100, 100);

    // Enemies
    const types = ['Rusher', 'Shield', 'Sniper'];
    for(let i=0; i<5+level; i++) {
        let ex = rand(200, width-50), ey = rand(200, height-50);
        // Ensure no spawn in wall
        let type = types[Math.floor(Math.random()*types.length)];
        enemies.push(new Enemy(ex, ey, type));
    }
    
    uiLevel.innerText = level;
    msgEl.style.display = 'none';
    timeScale = 1.0;
}

function update() {
    if (gameState !== 'playing') return;
    
    // Apply Slow Mo Logic
    timeScale = baseTimeScale;
    
    // UI Update
    uiWeapon.innerText = player.weapon.type;
    uiAmmo.innerText = player.weapon.ammo === Infinity ? "∞" : player.weapon.ammo;
    uiScore.innerText = "SCORE: " + score;
    if(comboCount > 1) {
        uiCombo.style.display = "block";
        uiCombo.innerText = "COMBO x" + comboCount;
        uiCombo.style.opacity = comboTimer/90;
    } else uiCombo.style.display = "none";
    
    if(comboTimer > 0) comboTimer -= 1 * timeScale;
    
    if (camShake > 0) camShake *= 0.9;
    if (camShake < 0.5) camShake = 0;

    if (!player.dead) player.update();

    // Ghosts
    for(let i=ghosts.length-1; i>=0; i--) {
        ghosts[i].life -= 0.05 * timeScale;
        if(ghosts[i].life <= 0) ghosts.splice(i,1);
    }
    
    // Explosions
    for(let i=explosions.length-1; i>=0; i--) {
        explosions[i].update();
        if(explosions[i].life <= 0) explosions.splice(i,1);
    }

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.update();
        if (b.dead) { bullets.splice(i, 1); continue; }

        if (b.owner === 'player') {
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let dist = Math.hypot(b.x - e.x, b.y - e.y);
                let hitRadius = b.type === 'melee' ? b.radius : 15;
                
                // Hit check
                let hit = false;
                if (b.type === 'melee') {
                    // Arc Check
                    if(dist < hitRadius) {
                        let angleDiff = Math.abs(Math.atan2(e.y - b.y, e.x - b.x) - b.angle);
                        while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                        if(Math.abs(angleDiff) < Math.PI/2) hit = true;
                    }
                } else {
                    if (dist < hitRadius) hit = true;
                }

                if (hit) {
                    let kill = true;
                    // Shield Logic
                    if (e.type === 'Shield' && b.type === 'normal') {
                        let angleToBullet = Math.atan2(b.y - e.y, b.x - e.x);
                        let angleDiff = Math.abs(angleToBullet - e.angle);
                        while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                        if(Math.abs(angleDiff) < 1.5) { kill = false; b.dead = true; spawnParticles(b.x, b.y, '#0AF', 2); }
                    }

                    if (b.type === 'thrown' || b.type === 'grenade') kill = true; 

                    if (kill) {
                        killEnemy(j, e);
                        if(b.type !== 'rail' && b.type !== 'melee') b.dead = true;
                    }
                }
            }
        } else {
            // Enemy Bullet vs Player
            if(Math.hypot(b.x - player.x, b.y - player.y) < 15) killPlayer();
            
            // Melee parry
            if(player.weapon.type === 'Data-Blade' && player.weapon.cooldown > 15) {
                 // Simple proximity parry if swinging
                 if(Math.hypot(b.x - player.x, b.y - player.y) < 60) {
                     b.dead = true;
                     spawnParticles(b.x, b.y, '#FFF', 2);
                 }
            }
        }
    }

    enemies.forEach(e => e.update());
    particles.forEach(p => {
        p.x += p.vx * timeScale; p.y += p.vy * timeScale; p.life -= 0.05 * timeScale;
    });
    particles = particles.filter(p => p.life > 0);
    floatingTexts.forEach(t => t.update());
    floatingTexts = floatingTexts.filter(t => t.life > 0);

    // Level End
    if(enemies.length === 0 && !player.dead) {
        msgEl.style.display = 'block';
        baseTimeScale = 0.1; // Matrix finish
        setTimeout(() => { level++; generateLevel(); }, 2000);
    }
}

function draw() {
    // BG
    ctx.fillStyle = (keys['ShiftLeft'] && player.focus > 0) ? '#001100' : '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    let sx = rand(-camShake, camShake); let sy = rand(-camShake, camShake);
    ctx.translate(sx, sy);

    // Walls
    ctx.fillStyle = '#000'; ctx.strokeStyle = '#0033FF'; ctx.lineWidth = 2;
    ctx.shadowBlur = 5; ctx.shadowColor = '#0033FF';
    for(let w of walls) { ctx.fillRect(w.x, w.y, w.w, w.h); ctx.strokeRect(w.x, w.y, w.w, w.h); }

    // Pickups
    for(let p of pickups) {
        ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 10;
        ctx.font="12px Courier"; ctx.fillText(p.type[0], p.x-4, p.y-10);
        ctx.fillRect(p.x-5, p.y-5, 10, 10);
    }

    // Ghosts
    for(let g of ghosts) {
        ctx.save(); ctx.translate(g.x, g.y); ctx.rotate(g.angle);
        ctx.globalAlpha = g.life; ctx.strokeStyle = '#00FFFF'; ctx.strokeRect(-10,-10,20,20);
        ctx.restore();
    }
    ctx.globalAlpha = 1;

    if(!player.dead) player.draw();
    enemies.forEach(e => e.draw());
    explosions.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;

    floatingTexts.forEach(t => t.draw());

    ctx.restore();
    frameCount++;
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-overlay').style.display = 'none';
    AudioSys.init();
    gameState = 'playing';
    generateLevel();
    loop();
}

/** INPUT */
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', e => {
    if(gameState !== 'playing') return;
    if(e.button === 0) player.shoot();
    if(e.button === 2) player.throwWeapon();
});
window.addEventListener('contextmenu', e => e.preventDefault());

</script>
</body>
</html>
