<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Scavenger: Overdrive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
        #score-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
        .hud-text { font-size: 20px; font-weight: bold; margin-bottom: 5px; }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            text-shadow: 0 0 20px #0f0;
            color: #0f0;
            display: none;
            text-align: center;
            font-weight: 900;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="weapon-display" class="hud-text">WEAPON: DATA-BLADE</div>
    <div id="ammo-display" class="hud-text">AMMO: ∞</div>
    <div id="level-display" class="hud-text">LEVEL: 1</div>
</div>

<div id="score-ui">
    <div id="score-display" class="hud-text">SCORE: 0</div>
    <div id="combo-display" class="hud-text" style="color: #ff0055; display: none;">COMBO x2</div>
</div>

<div id="message">SYSTEM HACKED</div>
<canvas id="gameCanvas"></canvas>

<script>
/**
 * SETUP & CONSTANTS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiWeapon = document.getElementById('weapon-display');
const uiAmmo = document.getElementById('ammo-display');
const uiLevel = document.getElementById('level-display');
const uiScore = document.getElementById('score-display');
const uiCombo = document.getElementById('combo-display');
const msgEl = document.getElementById('message');

let width, height;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input State
const keys = {};
const mouse = { x: 0, y: 0 };

// Game State
let level = 1;
let score = 0;
let gameState = 'playing'; 
let frameCount = 0;
let timeScale = 1.0; // For Matrix Slow-Mo

// Combo System
let comboCount = 0;
let comboTimer = 0;
const COMBO_WINDOW = 90; // 1.5 seconds at 60fps

// Entities
let player;
let enemies = [];
let bullets = [];
let particles = [];
let walls = [];
let pickups = [];
let floatingTexts = [];

// Screen Shake
let camShake = 0;

/**
 * UTILITIES
 */
function rand(min, max) { return Math.random() * (max - min) + min; }

function checkRectCollide(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

function getAngle(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1); }

// Line intersection for Raycasting
function lineIntersectRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    const left   = lineLine(x1,y1,x2,y2, rx,ry,rx,ry+rh);
    const right  = lineLine(x1,y1,x2,y2, rx+rw,ry,rx+rw,ry+rh);
    const top    = lineLine(x1,y1,x2,y2, rx,ry,rx+rw,ry);
    const bottom = lineLine(x1,y1,x2,y2, rx,ry+rh,rx+rw,ry+rh);
    return left || right || top || bottom;
}

function lineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
    const uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
    const uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
    return (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1);
}

function hasLineOfSight(ent1, ent2) {
    for (let w of walls) {
        if (lineIntersectRect(ent1.x, ent1.y, ent2.x, ent2.y, w.x, w.y, w.w, w.h)) {
            return false;
        }
    }
    return true;
}

function addScore(amount, x, y) {
    // Combo Logic
    if (comboTimer > 0) {
        comboCount++;
    } else {
        comboCount = 1;
    }
    comboTimer = COMBO_WINDOW;

    // Calc Score
    const total = amount * comboCount;
    score += total;
    
    // Float Text
    let txt = `+${amount}`;
    let color = '#FFF';
    let size = 16;
    
    if (comboCount > 1) {
        txt = `${comboCount}x COMBO!`;
        color = '#FFFF00';
    }
    if (comboCount === 2) txt = "DOUBLE KILL!";
    if (comboCount === 3) txt = "TRIPLE KILL!";
    if (comboCount >= 4) {
        txt = "RAMPAGE!"; 
        color = '#FF0000';
        size = 24;
    }

    floatingTexts.push(new FloatingText(x, y, txt, color, size));
}

function triggerShake(amount) {
    camShake = Math.max(camShake, amount);
}

/**
 * CLASSES
 */

class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.size = size;
        this.life = 1.0;
        this.vy = -1;
    }
    update() {
        this.y += this.vy * timeScale;
        this.life -= 0.02 * timeScale;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px Courier New`;
        ctx.textAlign = "center";
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 4;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = rand(3, 6);
        const angle = rand(0, Math.PI * 2);
        const vel = rand(1, speed);
        this.vx = Math.cos(angle) * vel;
        this.vy = Math.sin(angle) * vel;
        this.life = 1.0;
        this.decay = rand(0.02, 0.05);
    }
    update() {
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        this.life -= this.decay * timeScale;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class Weapon {
    constructor(type) {
        this.type = type;
        this.cooldown = 0;
        this.maxCooldown = 0;
        
        if (type === 'Pistol') {
            this.color = '#FFFF00'; // Yellow
            this.ammo = 6;
            this.maxCooldown = 15;
        } else if (type === 'Shotgun') {
            this.color = '#00FFFF'; // Cyan
            this.ammo = 2;
            this.maxCooldown = 40;
        } else if (type === 'Data-Blade') {
            this.color = '#FFFFFF';
            this.ammo = Infinity;
            this.maxCooldown = 25; // Slower swing for balance
        }
    }
}

class Bullet {
    constructor(x, y, angle, speed, color, ownerType, isMelee = false, isRailgun = false, isThrown = false) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = speed;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.color = color;
        this.ownerType = ownerType;
        this.radius = isMelee ? 70 : 3; // BUFF: 70px Melee Range
        this.isMelee = isMelee;
        this.isRailgun = isRailgun;
        this.isThrown = isThrown;
        this.life = isMelee ? 8 : 100; // Short life for melee arc
        this.dead = false;
        
        if(this.isThrown) this.radius = 8;
    }

    update() {
        // Melee moves with player (attached) but rotates? 
        // For this "Slash" feel, we keep it stationary where swung or move it slightly.
        // Let's make melee static "Area of Effect" relative to creation, simulating a swift strike.
        if (!this.isMelee) {
            this.x += this.vx * timeScale;
            this.y += this.vy * timeScale;
        }

        this.life -= 1 * timeScale;
        if (this.life <= 0) this.dead = true;

        if (!this.isRailgun && !this.isMelee) {
            for (let w of walls) {
                if (this.x > w.x && this.x < w.x + w.w && 
                    this.y > w.y && this.y < w.y + w.h) {
                    this.dead = true;
                    spawnParticles(this.x, this.y, this.color, 2);
                    return;
                }
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.isMelee) {
            // BUFFED VISUAL: Large Arc
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 4;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#FFF';
            ctx.beginPath();
            // Draw arc facing the direction of attack
            // 180 degrees centered on angle
            ctx.arc(0, 0, this.radius, this.angle - Math.PI/2, this.angle + Math.PI/2);
            ctx.stroke();
            
            // Inner fade
            ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
            ctx.fill();
        } else if (this.isThrown) {
            ctx.rotate(frameCount * 0.5);
            ctx.fillStyle = this.color;
            ctx.fillRect(-6, -6, 12, 12);
        } else {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5;
            ctx.shadowColor = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

class Entity {
    constructor(x, y, size, color) {
        this.x = x;
        this.y = y;
        this.w = size;
        this.h = size;
        this.color = color;
        this.angle = 0;
        this.dead = false;
    }

    move(speed) {
        let nextX = this.x + Math.cos(this.angle) * speed * timeScale;
        let nextY = this.y + Math.sin(this.angle) * speed * timeScale;
        
        let hitX = false;
        for (let w of walls) {
            if (checkRectCollide({x: nextX - this.w/2, y: this.y - this.h/2, w: this.w, h: this.h}, w)) hitX = true;
        }
        if (!hitX) this.x = nextX;

        let hitY = false;
        for (let w of walls) {
            if (checkRectCollide({x: this.x - this.w/2, y: nextY - this.h/2, w: this.w, h: this.h}, w)) hitY = true;
        }
        if (!hitY) this.y = nextY;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 20, '#FFFFFF');
        this.weapon = new Weapon('Data-Blade');
        this.muzzleTimer = 0;
    }

    update() {
        // Look at mouse
        this.angle = getAngle(this.x, this.y, mouse.x, mouse.y);

        // Movement
        let dx = 0, dy = 0;
        if (keys['KeyW']) dy = -1;
        if (keys['KeyS']) dy = 1;
        if (keys['KeyA']) dx = -1;
        if (keys['KeyD']) dx = 1;

        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
            const speed = 4;
            
            let nextX = this.x + dx * speed * timeScale;
            let collideX = false;
            for(let w of walls) if(checkRectCollide({x: nextX-10, y: this.y-10, w: 20, h: 20}, w)) collideX = true;
            if(!collideX) this.x = nextX;

            let nextY = this.y + dy * speed * timeScale;
            let collideY = false;
            for(let w of walls) if(checkRectCollide({x: this.x-10, y: nextY-10, w: 20, h: 20}, w)) collideY = true;
            if(!collideY) this.y = nextY;
        }

        if (this.weapon.cooldown > 0) this.weapon.cooldown -= 1 * timeScale;
        if (this.muzzleTimer > 0) this.muzzleTimer -= 1 * timeScale;

        // Pickups
        for (let i = pickups.length - 1; i >= 0; i--) {
            let p = pickups[i];
            let dist = Math.hypot(this.x - p.x, this.y - p.y);
            if (dist < 20) {
                this.weapon = new Weapon(p.type);
                pickups.splice(i, 1);
                triggerShake(2); // Small rumble on pickup
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#FFFFFF';
        ctx.fillStyle = this.color;
        ctx.fillRect(-10, -10, 20, 20);
        
        // Gun visual
        ctx.fillStyle = this.weapon.color;
        ctx.fillRect(5, -4, 12, 8);

        // Muzzle Flash
        if (this.muzzleTimer > 0) {
            ctx.fillStyle = '#FFFFaa';
            ctx.beginPath();
            ctx.arc(20, 0, 8, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }

    shoot() {
        if (this.weapon.cooldown > 0) return;

        if (this.weapon.type === 'Data-Blade') {
            // Melee Swipe
            // Spawn melee object slightly in front of player
            bullets.push(new Bullet(this.x, this.y, this.angle, 0, '#FFF', 'player', true));
            this.weapon.cooldown = this.weapon.maxCooldown;
            triggerShake(2); 
        } else if (this.weapon.ammo > 0) {
            // Shoot
            this.muzzleTimer = 2; // Show flash
            triggerShake(5); // Shake!

            if (this.weapon.type === 'Pistol') {
                bullets.push(new Bullet(this.x, this.y, this.angle, 12, this.weapon.color, 'player'));
            } else if (this.weapon.type === 'Shotgun') {
                for(let i=-2; i<=2; i++) {
                    bullets.push(new Bullet(this.x, this.y, this.angle + (i*0.1), 12, this.weapon.color, 'player'));
                }
                triggerShake(8); // Bigger shake for shotgun
            }
            this.weapon.ammo--;
            this.weapon.cooldown = this.weapon.maxCooldown;
        }
    }

    throwWeapon() {
        if (this.weapon.type === 'Data-Blade') return; 
        bullets.push(new Bullet(this.x, this.y, this.angle, 15, this.weapon.color, 'player', false, false, true));
        this.weapon = new Weapon('Data-Blade');
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 20, '#F00');
        this.type = type; 
        this.sniperState = 0; 
        this.sniperTimer = 0;
    }

    update() {
        if (this.dead) return;
        
        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
        const angleToPlayer = getAngle(this.x, this.y, player.x, player.y);
        const canSeePlayer = hasLineOfSight(this, player);

        if (this.type === 'Rusher') {
            this.angle = angleToPlayer;
            this.move(2.5);
            if (distToPlayer < 25) playerDie();
        } 
        else if (this.type === 'Shield') {
            let diff = angleToPlayer - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.05 * timeScale;

            if (distToPlayer > 100) this.move(1.0);
        } 
        else if (this.type === 'Sniper') {
            if (this.sniperState === 0) {
                if (canSeePlayer) {
                    this.sniperState = 1;
                    this.sniperTimer = 90;
                } else {
                    this.angle += rand(-0.1, 0.1) * timeScale;
                    this.move(0.5);
                }
            } else if (this.sniperState === 1) {
                this.angle = angleToPlayer;
                this.sniperTimer -= 1 * timeScale;
                if (!canSeePlayer) this.sniperState = 0;
                if (this.sniperTimer <= 0) {
                    bullets.push(new Bullet(this.x, this.y, this.angle, 30, '#F0F', 'enemy', false, true));
                    triggerShake(5);
                    this.sniperState = 2;
                    this.sniperTimer = 120;
                }
            } else if (this.sniperState === 2) {
                this.sniperTimer -= 1 * timeScale;
                if (this.sniperTimer <= 0) this.sniperState = 0;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        if (this.type === 'Rusher') {
            ctx.fillStyle = '#00FF00';
            ctx.shadowColor = '#00FF00';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-10, -10);
            ctx.fill();
        } 
        else if (this.type === 'Shield') {
            ctx.fillStyle = '#0000FF';
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-10, -10);
            ctx.fill();

            // Shield Arc
            ctx.strokeStyle = '#00AAFF';
            ctx.shadowColor = '#00AAFF';
            ctx.shadowBlur = 15;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 22, -Math.PI/2, Math.PI/2);
            ctx.stroke();
        } 
        else if (this.type === 'Sniper') {
            ctx.fillStyle = '#AA00FF';
            ctx.shadowColor = '#AA00FF';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 8);
            ctx.lineTo(-6, 0);
            ctx.lineTo(-10, -8);
            ctx.fill();

            if (this.sniperState === 1) {
                ctx.restore();
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(player.x, player.y);
                ctx.stroke();
                ctx.restore();
                return;
            }
        }
        ctx.restore();
    }
}

class Pickup {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.timer = 0;
        this.color = (type === 'Pistol') ? '#FFFF00' : '#00FFFF';
    }
    draw() {
        this.timer += 0.1;
        const bob = Math.sin(this.timer) * 3;
        ctx.save();
        ctx.translate(this.x, this.y + bob);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        
        ctx.font = "12px Courier";
        ctx.textAlign = "center";
        ctx.fillText(this.type[0], 0, -10);
        ctx.fillRect(-5, -5, 10, 10);
        ctx.restore();
    }
}

/**
 * GAME ENGINE
 */

function spawnParticles(x, y, color, speed) {
    for (let i = 0; i < 20; i++) {
        particles.push(new Particle(x, y, color, speed));
    }
}

function generateLevel() {
    walls = [];
    enemies = [];
    pickups = [];
    bullets = [];
    particles = [];
    timeScale = 1.0; 

    walls.push({x: 0, y: 0, w: width, h: 20});
    walls.push({x: 0, y: height-20, w: width, h: 20});
    walls.push({x: 0, y: 0, w: 20, h: height});
    walls.push({x: width-20, y: 0, w: 20, h: height});

    const numWalls = 10 + level * 2;
    for (let i = 0; i < numWalls; i++) {
        let w = rand(50, 200);
        let h = rand(50, 200);
        let x = rand(100, width - 100 - w);
        let y = rand(100, height - 100 - h);
        walls.push({x, y, w, h});
    }

    let safe = false;
    while (!safe) {
        player = new Player(rand(100, width-100), rand(100, height-100));
        safe = true;
        for (let w of walls) {
            if (checkRectCollide({x: player.x, y: player.y, w: 20, h: 20}, w)) safe = false;
        }
    }

    const enemyTypes = ['Rusher', 'Shield', 'Sniper'];
    const count = 4 + level;
    for (let i = 0; i < count; i++) {
        let safe = false;
        let ex, ey;
        while (!safe) {
            ex = rand(50, width-50);
            ey = rand(50, height-50);
            safe = true;
            for (let w of walls) {
                if (checkRectCollide({x: ex, y: ey, w: 20, h: 20}, w)) safe = false;
            }
            if (Math.hypot(ex - player.x, ey - player.y) < 300) safe = false;
        }
        let type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        if (level === 1) type = (Math.random() > 0.3) ? 'Rusher' : 'Shield';
        enemies.push(new Enemy(ex, ey, type));
    }

    uiLevel.innerText = "LEVEL: " + level;
    msgEl.style.display = 'none';
}

function playerDie() {
    triggerShake(20); // Massive shake
    spawnParticles(player.x, player.y, '#FFF', 5);
    player.x = -1000;
    player.dead = true;
    comboCount = 0;
    setTimeout(() => {
        score = Math.floor(score * 0.9); // Penalty
        level = 1;
        generateLevel();
    }, 1500);
}

function update() {
    if (player.dead) {
        // Still update particles
        particles.forEach(p => p.update());
        return;
    }

    // Cam Shake Decay
    if (camShake > 0) camShake *= 0.9;
    if (camShake < 0.5) camShake = 0;

    // Combo Timer
    if (comboTimer > 0) {
        comboTimer -= 1 * timeScale;
        if (comboTimer <= 0) comboCount = 0;
    }

    player.update();

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.update();
        if (b.dead) {
            bullets.splice(i, 1);
            continue;
        }

        if (b.ownerType === 'player') {
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let dist = Math.hypot(b.x - e.x, b.y - e.y);
                let hitDist = b.radius + 15;

                // Special Melee Collision Logic (Hitbox Arc)
                let isHit = false;
                
                if (b.isMelee) {
                    if (dist < hitDist) {
                        // Check Angle
                        let angleToEnemy = Math.atan2(e.y - b.y, e.x - b.x);
                        let angleDiff = angleToEnemy - b.angle;
                        // Normalize angleDiff
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        
                        // 180 degree view = PI/2 either side
                        if (Math.abs(angleDiff) < Math.PI / 2) {
                            isHit = true;
                        }
                    }
                } else {
                    // Standard Bullet
                    if (dist < hitDist) isHit = true;
                }

                if (isHit) {
                    let kill = true;
                    if (e.type === 'Shield' && !b.isMelee) {
                        let angleToBullet = Math.atan2(b.y - e.y, b.x - e.x);
                        let angleDiff = Math.abs(angleToBullet - e.angle);
                        while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                        if (Math.abs(angleDiff) < 1.5) { 
                            kill = false;
                            b.dead = true;
                            spawnParticles(b.x, b.y, '#00AAFF', 3);
                        }
                    }

                    if (b.isThrown) kill = true;

                    if (kill) {
                        spawnParticles(e.x, e.y, e.color, 4);
                        triggerShake(6); // Medium shake on kill
                        addScore(100, e.x, e.y); // Add Score & Floating Text

                        if (Math.random() < 0.5) {
                            if (e.type === 'Shield') pickups.push(new Pickup(e.x, e.y, 'Shotgun'));
                            else if (e.type === 'Sniper') pickups.push(new Pickup(e.x, e.y, 'Pistol'));
                            else pickups.push(new Pickup(e.x, e.y, 'Pistol'));
                        }

                        enemies.splice(j, 1);
                        b.dead = true;
                        if (b.isMelee || b.isRailgun) b.dead = false;
                    }
                }
            }
        } else if (b.ownerType === 'enemy') {
            if (Math.hypot(b.x - player.x, b.y - player.y) < 15) playerDie();
        }
    }

    bullets.filter(b => b.isMelee).forEach(melee => {
        bullets.filter(b => b.ownerType === 'enemy').forEach(eb => {
            // Check arc for bullet parry too!
            let dist = Math.hypot(melee.x - eb.x, melee.y - eb.y);
            if (dist < melee.radius) {
                let angleToBullet = Math.atan2(eb.y - melee.y, eb.x - melee.x);
                let angleDiff = angleToBullet - melee.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (Math.abs(angleDiff) < Math.PI / 2) {
                    eb.dead = true;
                    spawnParticles(eb.x, eb.y, '#FFF', 1);
                }
            }
        });
    });

    enemies.forEach(e => e.update());
    particles.forEach(p => p.update());
    floatingTexts.forEach(ft => ft.update());
    particles = particles.filter(p => p.life > 0);
    floatingTexts = floatingTexts.filter(ft => ft.life > 0);

    uiWeapon.innerText = "WEAPON: " + player.weapon.type.toUpperCase();
    uiAmmo.innerText = "AMMO: " + (player.weapon.ammo === Infinity ? "∞" : player.weapon.ammo);
    uiScore.innerText = "SCORE: " + score;
    
    if (comboCount > 1) {
        uiCombo.style.display = "block";
        uiCombo.innerText = "COMBO x" + comboCount;
        uiCombo.style.opacity = (comboTimer / COMBO_WINDOW).toFixed(2);
    } else {
        uiCombo.style.display = "none";
    }

    // Level Finish / Matrix Slow Mo
    if (enemies.length === 0 && gameState === 'playing') {
        gameState = 'transition';
        timeScale = 0.1; // MATRIX SLOW MO
        msgEl.innerText = "SYSTEM HACKED";
        msgEl.style.display = 'block';
        
        setTimeout(() => {
            level++;
            gameState = 'playing';
            generateLevel();
        }, 2000);
    }
}

function draw() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    
    // Screen Shake Apply
    let sx = rand(-camShake, camShake);
    let sy = rand(-camShake, camShake);
    ctx.translate(sx, sy);

    ctx.fillStyle = '#000000';
    ctx.strokeStyle = '#0033FF';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 5;
    ctx.shadowColor = '#0033FF';
    for (let w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeRect(w.x, w.y, w.w, w.h);
    }

    pickups.forEach(p => p.draw());
    if (!player.dead) player.draw();
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());
    floatingTexts.forEach(ft => ft.draw());

    ctx.restore();
    frameCount++;
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

/**
 * INPUTS
 */
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.code] = false; });
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', e => {
    if (e.button === 0 && player && !player.dead) player.shoot();
    if (e.button === 2 && player && !player.dead) player.throwWeapon();
});
window.addEventListener('contextmenu', e => e.preventDefault());

generateLevel();
loop();

</script>
</body>
</html>
